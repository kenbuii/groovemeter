# -*- coding: utf-8 -*-
"""DATASCI_FINAL_PROJECT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VZIxeD7QJDpHKvkwCsSN4DWX6pgZ0qZ_

# Final Project for DATASCI 112:
Authors: Kenneth Bui and Amaryllis Gao

In this project, we aim to classify the *danceability* of a song based on a series of input features, and build a short webapp by which users can input their own Spotify User IDs and receive a short danceability score report.
"""

# import packages
import os
import json
import requests
import pandas as pd

def get_access_token(client_id: str, client_secret: str, grant_type: str = 'client_credentials'):
    url = 'https://accounts.spotify.com/api/token?grant_type={}&client_id={}&client_secret={}'.format(grant_type, client_id, client_secret)
    response = requests.post(url, headers={'Content-Type':'application/x-www-form-urlencoded'})
    access_token = 'Bearer ' + json.loads(response.text)['access_token']

    return access_token


# get access token
grant_type = 'client_credentials'
client_id = os.getenv('SPOTIFY_CLIENT_ID')
client_secret = os.getenv('SPOTIFY_CLIENT_SECRET')

access_token = get_access_token(client_id, client_secret, grant_type)

"""# Making API calls

"""

def get_data(url: str, access_token: str, verbose: bool = False):
    response = requests.get(url, headers={'Authorization': access_token})
    result = json.loads(response.text)

    if verbose:
        print('Response body:\n', result)

    return result

"""# Data Collection: Getting Tracks

"""

def get_tracks(genres_list: list, steps: int, limit: int, offset: int, access_token: str):
    tracks_df = pd.DataFrame()
    _initial_offset = offset

    for genre in genres_list:

        for step in range(steps):
            url = 'https://api.spotify.com/v1/search?q=genre:{}&type=track&limit={}&offset={}'.format(genre, limit, offset)
            search_item = get_data(url, access_token)

            for n in range(limit):
                track_id = search_item['tracks']['items'][n]['id']
                track_name = search_item['tracks']['items'][n]['name']
                artist_name = search_item['tracks']['items'][n]['artists'][0]['name']
                popularity = search_item['tracks']['items'][n]['popularity']

                tracks_df = tracks_df.append({
                    'track_id': track_id,
                    'track_name': track_name,
                    'artist_name': artist_name,
                    'popularity': popularity,
                    'genre': genre
                }, ignore_index=True)

            offset += limit
        offset = _initial_offset

    return tracks_df

"""# Data Collection: Genre and Artists
Here, we scrape the Spotify API to find the top 10 artists for the following genres:

1.   Pop
1.   Indie
2.   R&B

We remove duplicates from each category, and extract the top 10 songs of each artist.
"""

#Scrape the genres and find top 10 artists
url = "https://spotify-scraper.p.rapidapi.com/v1/track/lyrics"

querystring = {"trackId": "4RL77hMWUq35NYnPLXBpih"}

headers = {
    "X-RapidAPI-Key": "1d28eb6b70msh4ceaf41b5a6c473p1e417fjsnc0e72884e283",
    "X-RapidAPI-Host": "spotify-scraper.p.rapidapi.com"
}

response = requests.get(url, headers=headers, params=querystring)

if response.status_code == 200:
    try:
        print(response.json())
    except requests.JSONDecodeError:
        print("Error: Response is not in JSON format.")
        print(response.text)
else:
    print(f"Error: Status code {response.status_code}")
    print(response.text)

response